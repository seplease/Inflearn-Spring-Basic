6.2: 고립된 단위 테스트
=
- 가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것
  - 테스트가 실패했을 때 원인을 찾기 쉬움
  - 테스트의 의도나 내용이 분명해짐
  - 만들기 쉬워짐

## 6.2.1 복잡한 의존관계 속의 테스트
- UserService는 세 가지의 의존관계를 갖고 있음
<br>&rarr; 세 가지 의존관게를 갖는 오브젝트들이 테스트가 진행되는 동안에 같이 실행됨
<br>&rarr; UserService 뒤에 존재하는 훨씬 더 많은 객체, 환경, 서비스, 서버, 네트워크까지 테스트하는 셈
- 즉, UserService라는 테스트 대상이 테스트 단위인 것처럼 보이지만 사실은 그 뒤의 의존관계를 따라 등장하는 오브젝트와 서비스, 환경 등이 모두 합쳐져 테스트 대상이 되는 것
  - 이런 경우, 테스트 준비가 힘듦
  - 환경이 조금이라도 달라지면 동일한 테스트 결과를 내지 못할 수 있음
  - 수행 속도 느림
  - 코드를 잘못 수정한다면 그 오류 때문에 원인을 찾느라 불필요한 시간 낭비가 됨

## 6.2.2 테스트 대상 오브젝트 고립시키기
- 테스트의 대상이 환경이나, 외부 서버, 다른 클래스에 종속되고 영향받지 않도록 고립시킬 필요가 있음
<br>&rarr; 테스트를 위한 대역 사용
- 장점
  - 다른 요소를 배제한 UserService의 기능만을 테스트 가능
  - 다른 요소들에 필요한 자원들을 소모하지 않으므로 수행 성능이 좋음 (속도 향상)

## 6.2.3 단위 테스트와 통합 테스트
- 단위 테스트: 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 의존해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트하
- 통합 테스트: 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트
<br>&rarr; 즉 두 개 이상의 단위가 결합해서 동작하면서 테스트가 수행되는 것
- 선택 가이드라인
  - 항상 단위 테스트 먼저 고려
  - 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트
  - 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려.
이때도 통합 테스트에 참여하는 코드 중에서 가능한 한 많은 부분을 미리 단위 테스트로 검증해두기

💡 참고
- 코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관이다.
- 테스트하기 편하게 만들어진 코드는 깔끔하고 좋은 코드가 될 가능성이 높다.

### 6.2.4 목 프레임워크
- Mockito 프레임워크
  - 목 클래스를 일일이 준비할 필요 없음
  - 간단한 메소드 호출만으로 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있음